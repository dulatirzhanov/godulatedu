<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>UTM Конструктор — dulatedu</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #eef2ff;
      --bg-accent: #dbeafe;
      --panel: rgba(255, 255, 255, 0.9);
      --panel-strong: rgba(255, 255, 255, 0.98);
      --border: rgba(15, 23, 42, 0.12);
      --border-strong: rgba(15, 23, 42, 0.18);
      --text: #0f172a;
      --muted: #475569;
      --accent: #2563eb;
      --accent-dark: #1d4ed8;
      --success: #16a34a;
      --danger: #dc2626;
      --radius-lg: 24px;
      --radius-md: 16px;
      --radius-sm: 12px;
      --shadow-lg: 0 30px 60px rgba(15, 23, 42, 0.18);
      --shadow-sm: 0 16px 40px rgba(37, 99, 235, 0.12);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;
      background: radial-gradient(circle at 20% -10%, #cbd5f5 0%, var(--bg) 55%, #f8fafc 100%);
      color: var(--text);
      display: flex;
      justify-content: center;
      padding: 48px 16px 64px;
    }

    main {
      width: min(1080px, 100%);
      display: grid;
      gap: 32px;
    }

    header {
      text-align: center;
      display: grid;
      gap: 12px;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.8rem, 4vw, 2.6rem);
      font-weight: 700;
      letter-spacing: -0.03em;
    }

    p.lead {
      margin: 0 auto;
      max-width: 52ch;
      color: var(--muted);
      font-size: clamp(1rem, 2.8vw, 1.125rem);
      line-height: 1.6;
    }

    .layout {
      display: grid;
      gap: 24px;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: clamp(24px, 3vw, 36px);
      box-shadow: var(--shadow-lg);
      backdrop-filter: blur(18px);
      display: grid;
      gap: 24px;
    }

    .panel-heading {
      display: grid;
      gap: 8px;
    }

    .panel-heading h2 {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 700;
      letter-spacing: -0.01em;
    }

    .panel-heading p {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
      line-height: 1.6;
    }

    form {
      display: grid;
      gap: 20px;
    }

    fieldset {
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: 16px;
      margin: 0;
      display: grid;
      gap: 14px;
      background: var(--panel-strong);
    }

    legend {
      padding: 0 8px;
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--muted);
    }

    .field {
      display: grid;
      gap: 6px;
    }

    label {
      font-weight: 600;
      font-size: 0.95rem;
    }

    input[type="text"],
    select,
    textarea {
      width: 100%;
      padding: 12px 14px;
      font-size: 1rem;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.94);
      color: inherit;
      transition: border 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
    }

    input[type="text"]:focus,
    select:focus,
    textarea:focus,
    button:focus-visible {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.18);
    }

    .inputs-grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .chip {
      border: 1px solid rgba(37, 99, 235, 0.25);
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.1);
      color: var(--accent-dark);
      padding: 7px 16px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background 0.15s ease, transform 0.15s ease, box-shadow 0.15s ease;
    }

    .chip:hover,
    .chip:focus-visible {
      transform: translateY(-1px);
      box-shadow: 0 12px 20px rgba(37, 99, 235, 0.18);
    }

    .chip.is-active {
      background: var(--accent);
      color: #fff;
      box-shadow: 0 16px 24px rgba(37, 99, 235, 0.32);
    }

    .helper-text {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
      line-height: 1.5;
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    button {
      border: none;
      border-radius: var(--radius-sm);
      padding: 12px 20px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease, color 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      justify-content: center;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent), var(--accent-dark));
      color: #fff;
      box-shadow: 0 20px 40px rgba(37, 99, 235, 0.28);
    }

    .btn-primary:hover,
    .btn-primary:focus-visible {
      transform: translateY(-1px);
      box-shadow: 0 24px 44px rgba(37, 99, 235, 0.32);
    }

    .btn-secondary {
      background: rgba(15, 23, 42, 0.04);
      color: var(--text);
      border: 1px solid var(--border-strong);
      box-shadow: 0 14px 30px rgba(15, 23, 42, 0.08);
    }

    .btn-secondary:hover,
    .btn-secondary:focus-visible {
      transform: translateY(-1px);
      box-shadow: 0 18px 34px rgba(15, 23, 42, 0.12);
    }

    .result {
      display: grid;
      gap: 16px;
    }

    textarea {
      min-height: 96px;
      resize: vertical;
      line-height: 1.5;
    }

    .qr-wrapper {
      display: grid;
      gap: 16px;
      justify-items: start;
    }

    .qr-wrapper svg {
      border-radius: var(--radius-sm);
      box-shadow: var(--shadow-sm);
      background: #fff;
      padding: 12px;
    }

    canvas {
      image-rendering: pixelated;
    }

    .status {
      min-height: 1.4em;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .status.error {
      color: var(--danger);
      font-weight: 600;
    }

    #baseError {
      min-height: 1.2em;
    }

    .insight-list {
      margin: 0;
      padding-left: 20px;
      display: grid;
      gap: 8px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .insight-list li strong {
      color: var(--text);
    }

    code {
      font-family: "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: rgba(15, 23, 42, 0.08);
      color: var(--accent-dark);
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 0.85rem;
    }

    @media (max-width: 960px) {
      body {
        padding: 32px 16px 48px;
      }
    }

    @media (max-width: 640px) {
      body {
        padding: 24px 12px 40px;
      }

      .actions {
        flex-direction: column;
      }

      button {
        width: 100%;
      }

      .qr-wrapper {
        justify-items: stretch;
      }

      .qr-wrapper svg {
        margin: 0 auto;
      }
    }

    @media (prefers-color-scheme: dark) {
      :root {
        color-scheme: dark;
        --bg: #0f172a;
        --bg-accent: #1e293b;
        --panel: rgba(15, 23, 42, 0.78);
        --panel-strong: rgba(30, 41, 59, 0.82);
        --border: rgba(148, 163, 184, 0.18);
        --border-strong: rgba(148, 163, 184, 0.28);
        --text: #f8fafc;
        --muted: #cbd5f5;
      }

      body {
        background: radial-gradient(circle at 12% -10%, #1d4ed8 0%, #0f172a 60%, #020617 100%);
      }

      .btn-secondary {
        background: rgba(148, 163, 184, 0.08);
        color: var(--text);
      }

      textarea,
      input[type="text"],
      select {
        background: rgba(15, 23, 42, 0.7);
      }

      .chips {
        color: var(--text);
      }

      .chip {
        background: rgba(37, 99, 235, 0.22);
        border-color: rgba(37, 99, 235, 0.35);
      }

      .chip.is-active {
        background: rgba(37, 99, 235, 0.86);
      }

      code {
        background: rgba(148, 163, 184, 0.16);
        color: #bfdbfe;
      }
    }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>UTM Конструктор</h1>
      <p class="lead">Собирайте аккуратные трекинговые ссылки для dulatedu за пару минут: выберите пресет, обновите параметры и получите готовый результат.</p>
    </header>

    <div class="layout">
      <form id="utmForm" class="panel form-panel" novalidate>
        <div class="panel-heading">
          <h2>Параметры кампании</h2>
          <p>Все поля подписаны по-русски, доступ к элементам — с клавиатуры. Выберите пресет или заполните форму вручную.</p>
        </div>

        <fieldset aria-labelledby="presets-heading">
          <legend id="presets-heading">Готовые сценарии</legend>
          <div class="chips" role="list">
            <button class="chip" type="button" data-base="https://dulatedu.com/" data-source="instagram" data-medium="social" data-campaign="bio" data-content="instagram_profile">Instagram био</button>
            <button class="chip" type="button" data-base="https://dulatedu.com/" data-source="linkedin" data-medium="social" data-campaign="bio" data-content="linkedin_profile">LinkedIn био</button>
            <button class="chip" type="button" data-base="https://dulatedu.com/" data-source="telegram" data-medium="social" data-campaign="bio" data-content="telegram_profile">Telegram био</button>
            <button class="chip" type="button" data-base="https://dulatedu.com/" data-source="whatsapp" data-medium="social" data-campaign="bio" data-content="whatsapp_profile">WhatsApp био</button>
            <button class="chip" type="button" data-base="https://dulatedu.com/" data-source="event" data-medium="qr" data-campaign="nu_visit_2025" data-content="event_badge">Event QR (nu_visit_2025)</button>
          </div>
          <p class="helper-text">Пресеты мгновенно подставят значения и очистят результат, чтобы вы не потерялись в старых данных.</p>
        </fieldset>

        <div class="field">
          <label for="baseUrl">Базовая ссылка</label>
          <input id="baseUrl" name="baseUrl" type="text" placeholder="https://dulatedu.com/" autocomplete="url" required>
          <span id="baseError" class="status"></span>
          <p class="helper-text">Вставьте рабочий адрес страницы. Если забыли указать протокол, мы автоматически добавим https://.</p>
        </div>

        <div class="inputs-grid">
          <div class="field">
            <label for="utmSource">utm_source</label>
            <select id="utmSource" name="utm_source" required>
              <option value="">Выберите источник</option>
              <option value="instagram">instagram</option>
              <option value="linkedin">linkedin</option>
              <option value="telegram">telegram</option>
              <option value="whatsapp">whatsapp</option>
              <option value="facebook">facebook</option>
              <option value="email">email</option>
              <option value="event">event</option>
              <option value="other">other</option>
            </select>
          </div>
          <div class="field">
            <label for="utmMedium">utm_medium</label>
            <select id="utmMedium" name="utm_medium" required>
              <option value="">Выберите канал</option>
              <option value="social">social</option>
              <option value="referral">referral</option>
              <option value="cpc">cpc</option>
              <option value="email">email</option>
              <option value="qr">qr</option>
              <option value="banner">banner</option>
            </select>
          </div>
          <div class="field">
            <label for="utmCampaign">utm_campaign</label>
            <input id="utmCampaign" name="utm_campaign" type="text" placeholder="пример: spring_launch" required>
          </div>
          <div class="field">
            <label for="utmContent">utm_content <span style="color:var(--muted);font-weight:400;">(необязательно)</span></label>
            <input id="utmContent" name="utm_content" type="text" placeholder="пример: hero_button">
          </div>
          <div class="field">
            <label for="utmTerm">utm_term <span style="color:var(--muted);font-weight:400;">(необязательно)</span></label>
            <input id="utmTerm" name="utm_term" type="text" placeholder="пример: brand_keyword">
          </div>
        </div>

        <div class="actions">
          <button type="submit" class="btn-primary">Сгенерировать ссылку</button>
          <button type="button" id="copyBtn" class="btn-secondary">Скопировать</button>
          <button type="button" id="qrBtn" class="btn-secondary">Показать QR</button>
        </div>
      </form>

      <section class="panel result-panel" aria-labelledby="result-heading">
        <div class="panel-heading">
          <h2 id="result-heading">Готовая ссылка и QR</h2>
          <p>После генерации ссылка появится ниже. QR-код подходит для печати, визиток и презентаций.</p>
        </div>

        <div class="result" aria-live="polite">
          <div class="field">
            <label for="resultUrl">Готовая ссылка</label>
            <textarea id="resultUrl" readonly spellcheck="false"></textarea>
          </div>
          <div class="qr-wrapper">
            <div id="qrCode" aria-label="QR код" role="img"></div>
            <span id="statusMessage" class="status" role="status" aria-live="polite"></span>
          </div>
        </div>

        <div>
          <h3 style="margin:0;font-size:1rem;">Подсказки по кампании</h3>
          <ul class="insight-list">
            <li><strong>utm_source</strong> — площадка, где размещаете ссылку (instagram, telegram, linkedin и т.д.).</li>
            <li><strong>utm_medium</strong> — тип канала (social, qr, email, cpc, banner).</li>
            <li><strong>utm_campaign</strong> — название активности без пробелов, например <code>open_day_april</code>.</li>
          </ul>
        </div>
      </section>
    </div>
  </main>

  <script>
    (function () {
      const storageKey = 'utm_builder_state_v1';
      const defaultState = {
        baseUrl: 'https://dulatedu.com/',
        utm_source: 'instagram',
        utm_medium: 'social',
        utm_campaign: 'bio',
        utm_content: '',
        utm_term: ''
      };

      const form = document.getElementById('utmForm');
      const baseInput = document.getElementById('baseUrl');
      const sourceSelect = document.getElementById('utmSource');
      const mediumSelect = document.getElementById('utmMedium');
      const campaignInput = document.getElementById('utmCampaign');
      const contentInput = document.getElementById('utmContent');
      const termInput = document.getElementById('utmTerm');
      const resultField = document.getElementById('resultUrl');
      const copyBtn = document.getElementById('copyBtn');
      const qrBtn = document.getElementById('qrBtn');
      const qrContainer = document.getElementById('qrCode');
      const status = document.getElementById('statusMessage');
      const baseError = document.getElementById('baseError');
      const chips = Array.from(document.querySelectorAll('.chip'));

      function ensureScheme(url) {
        if (!url) return url;
        return /^https?:\/\//i.test(url) ? url : 'https://' + url;
      }

      function isValidHttpUrl(value) {
        try {
          const parsed = new URL(value);
          return parsed.protocol === 'http:' || parsed.protocol === 'https:';
        } catch (error) {
          return false;
        }
      }

      function collectState() {
        return {
          baseUrl: baseInput.value.trim(),
          utm_source: sourceSelect.value,
          utm_medium: mediumSelect.value,
          utm_campaign: campaignInput.value.trim(),
          utm_content: contentInput.value.trim(),
          utm_term: termInput.value.trim()
        };
      }

      function updateActiveChip() {
        const state = collectState();
        let activeChip = null;
        chips.forEach(function (chip) {
          const matches = (!chip.dataset.source || chip.dataset.source === state.utm_source)
            && (!chip.dataset.medium || chip.dataset.medium === state.utm_medium)
            && (!chip.dataset.campaign || chip.dataset.campaign === state.utm_campaign)
            && (!('content' in chip.dataset) || chip.dataset.content === state.utm_content)
            && (!('term' in chip.dataset) || chip.dataset.term === state.utm_term);
          if (matches && !activeChip) {
            activeChip = chip;
          }
        });
        chips.forEach(function (chip) {
          chip.classList.toggle('is-active', chip === activeChip);
        });
      }

      function persistState() {
        const state = collectState();
        try {
          localStorage.setItem(storageKey, JSON.stringify(state));
        } catch (error) {
          console.warn('Не удалось сохранить состояние', error);
        }
        updateActiveChip();
      }

      function hydrateState() {
        try {
          const raw = localStorage.getItem(storageKey);
          if (!raw) throw new Error('no state');
          const data = { ...defaultState, ...JSON.parse(raw) };
          baseInput.value = data.baseUrl || defaultState.baseUrl;
          sourceSelect.value = data.utm_source || '';
          mediumSelect.value = data.utm_medium || '';
          campaignInput.value = data.utm_campaign || '';
          contentInput.value = data.utm_content || '';
          termInput.value = data.utm_term || '';
        } catch (error) {
          baseInput.value = defaultState.baseUrl;
          sourceSelect.value = defaultState.utm_source;
          mediumSelect.value = defaultState.utm_medium;
          campaignInput.value = defaultState.utm_campaign;
          contentInput.value = defaultState.utm_content;
          termInput.value = defaultState.utm_term;
        }
        updateActiveChip();
      }

      function resetStatus(message, isError) {
        status.textContent = message || '';
        status.classList.toggle('error', Boolean(isError));
        baseError.textContent = '';
        baseError.classList.remove('error');
      }

      function showBaseError(message) {
        baseError.textContent = message;
        baseError.classList.add('error');
      }

      function clearQr() {
        while (qrContainer.firstChild) {
          qrContainer.removeChild(qrContainer.firstChild);
        }
      }

      function buildUrl() {
        const rawBase = ensureScheme(baseInput.value.trim());
        if (!rawBase) {
          showBaseError('Укажите базовую ссылку.');
          return '';
        }

        if (!isValidHttpUrl(rawBase)) {
          showBaseError('Введите корректный адрес с http или https.');
          return '';
        }

        baseInput.value = rawBase;
        const url = new URL(rawBase);
        const params = new URLSearchParams();

        const source = sourceSelect.value;
        const medium = mediumSelect.value;
        const campaign = campaignInput.value.trim();
        const content = contentInput.value.trim();
        const term = termInput.value.trim();

        if (!source || !medium || !campaign) {
          showBaseError('Заполните обязательные поля utm_source, utm_medium и utm_campaign.');
          return '';
        }

        params.set('utm_source', source);
        params.set('utm_medium', medium);
        params.set('utm_campaign', campaign);
        if (content) params.set('utm_content', content);
        if (term) params.set('utm_term', term);

        url.search = params.toString();
        const finalUrl = url.toString();
        resultField.value = finalUrl;
        resetStatus('Ссылка готова.');
        persistState();
        return finalUrl;
      }

      form.addEventListener('submit', function (event) {
        event.preventDefault();
        resetStatus('');
        clearQr();
        const url = buildUrl();
        if (url) {
          status.textContent = 'Ссылка сгенерирована.';
        }
      });

      [baseInput, sourceSelect, mediumSelect, campaignInput, contentInput, termInput].forEach(function (el) {
        el.addEventListener('input', function () {
          baseError.textContent = '';
          baseError.classList.remove('error');
          updateActiveChip();
        });
        const persist = function () {
          persistState();
        };
        el.addEventListener('change', persist);
        el.addEventListener('blur', persist);
      });

      copyBtn.addEventListener('click', function () {
        const url = resultField.value.trim() || buildUrl();
        if (!url) {
          resetStatus('Сначала сформируйте ссылку.', true);
          return;
        }
        navigator.clipboard.writeText(url).then(function () {
          resetStatus('Ссылка скопирована в буфер обмена.');
        }, function () {
          resetStatus('Не удалось скопировать ссылку.', true);
        });
      });

      qrBtn.addEventListener('click', function () {
        const url = resultField.value.trim() || buildUrl();
        if (!url) {
          resetStatus('Сначала сформируйте ссылку.', true);
          return;
        }
        clearQr();
        try {
          const qr = qrcode(0, 'M');
          qr.addData(url);
          qr.make();
          qrContainer.innerHTML = qr.createSvgTag({ scalable: true, margin: 2 });
          qrContainer.firstChild.setAttribute('width', '180');
          qrContainer.firstChild.setAttribute('height', '180');
          qrContainer.firstChild.setAttribute('role', 'img');
          qrContainer.firstChild.setAttribute('aria-label', 'QR код для созданной ссылки');
          resetStatus('QR-код готов к скачиванию или показу.');
        } catch (error) {
          clearQr();
          const message = error && error.message ? error.message : 'Неизвестная ошибка';
          resetStatus('Не удалось создать QR: ' + message, true);
        }
      });

      chips.forEach(function (chip) {
        chip.addEventListener('click', function () {
          const presetBase = chip.dataset.base;
          if (presetBase) {
            baseInput.value = presetBase;
          }
          if (chip.dataset.source) sourceSelect.value = chip.dataset.source;
          if (chip.dataset.medium) mediumSelect.value = chip.dataset.medium;
          if (chip.dataset.campaign) campaignInput.value = chip.dataset.campaign;
          contentInput.value = chip.dataset.content || '';
          termInput.value = chip.dataset.term || '';
          updateActiveChip();
          clearQr();
          resultField.value = '';
          resetStatus('Применен пресет «' + chip.textContent.trim() + '».');
          persistState();
        });
      });

      hydrateState();
      buildUrl();
    })();

    /*! qrcode.js v1.0.0 (minimal build) | MIT License | Kazuhiko Arase */
    (function() {
      var mode8bitByte = {
        mode: 4,
        getLength: function(buffer) {
          return buffer.length;
        },
        write: function(buffer, bitBuffer) {
          for (var i = 0; i < buffer.length; i++) {
            bitBuffer.put(buffer.charCodeAt(i), 8);
          }
        }
      };

      function qrPolynomial(num, shift) {
        if (typeof num.length === 'undefined') throw new Error(num.length + '/' + shift);
        var offset = 0;
        while (offset < num.length && num[offset] === 0) {
          offset++;
        }
        var _num = new Array(num.length - offset + shift);
        for (var i = 0; i < num.length - offset; i++) {
          _num[i] = num[i + offset];
        }
        return {
          get : function(index) {
            return _num[index];
          },
          getLength : function() {
            return _num.length;
          },
          multiply : function(e) {
            var num = new Array(this.getLength() + e.getLength() - 1);
            for (var i = 0; i < this.getLength(); i++) {
              for (var j = 0; j < e.getLength(); j++) {
                num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
              }
            }
            return qrPolynomial(num, 0);
          },
          mod : function(e) {
            if (this.getLength() - e.getLength() < 0) {
              return this;
            }
            var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
            var num = new Array(this.getLength());
            for (var i = 0; i < this.getLength(); i++) {
              num[i] = this.get(i);
            }
            for (var j = 0; j < e.getLength(); j++) {
              num[j] ^= QRMath.gexp(QRMath.glog(e.get(j)) + ratio);
            }
            return qrPolynomial(num, 0).mod(e);
          }
        };
      }

      var QRMath = {
        glog : function(n) {
          if (n < 1) { throw new Error('glog(' + n + ')'); }
          return QRMath.LOG_TABLE[n];
        },
        gexp : function(n) {
          while (n < 0) { n += 255; }
          while (n >= 256) { n -= 255; }
          return QRMath.EXP_TABLE[n];
        },
        EXP_TABLE : new Array(256),
        LOG_TABLE : new Array(256)
      };

      for (var i = 0; i < 8; i++) {
        QRMath.EXP_TABLE[i] = 1 << i;
      }
      for (i = 8; i < 256; i++) {
        QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
      }
      for (i = 0; i < 255; i++) {
        QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
      }

      function qrRSBlock(totalCount, dataCount) {
        return { totalCount: totalCount, dataCount: dataCount };
      }

      var ECC_CODEWORDS_PER_BLOCK = [
        null,
        [7, 10, 13, 17],
        [10, 16, 22, 28],
        [15, 26, 36, 44],
        [20, 36, 52, 64],
        [26, 48, 72, 88],
        [36, 64, 96, 112],
        [40, 72, 108, 130],
        [48, 88, 132, 156],
        [60, 110, 160, 192],
        [72, 130, 192, 224],
        [80, 150, 224, 264],
        [96, 176, 260, 308],
        [104, 198, 288, 352],
        [120, 216, 320, 384],
        [132, 240, 360, 432],
        [144, 280, 408, 480],
        [168, 308, 448, 532],
        [180, 338, 504, 588],
        [196, 364, 546, 650],
        [224, 416, 600, 700],
        [224, 442, 644, 750],
        [252, 476, 690, 816],
        [270, 504, 750, 900],
        [300, 560, 810, 960],
        [312, 588, 870, 1050],
        [336, 644, 952, 1110],
        [360, 700, 1020, 1200],
        [390, 728, 1050, 1260],
        [420, 784, 1140, 1350],
        [450, 812, 1200, 1440],
        [480, 868, 1290, 1530],
        [510, 924, 1350, 1620],
        [540, 980, 1440, 1710],
        [570, 1036, 1530, 1800],
        [570, 1064, 1590, 1890],
        [600, 1120, 1680, 1980],
        [630, 1204, 1770, 2100],
        [660, 1260, 1860, 2220],
        [720, 1316, 1950, 2310],
        [750, 1372, 2040, 2430]
      ];

      var NUM_ERROR_CORRECTION_BLOCKS = [
        null,
        [1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 2, 2],
        [1, 2, 2, 4],
        [1, 2, 2, 2],
        [2, 4, 4, 4],
        [2, 4, 6, 5],
        [2, 4, 6, 6],
        [2, 5, 8, 8],
        [4, 5, 8, 8],
        [4, 5, 8, 11],
        [4, 8, 10, 11],
        [4, 9, 12, 11],
        [4, 9, 12, 12],
        [6, 10, 12, 12],
        [6, 10, 14, 14],
        [6, 11, 14, 16],
        [6, 13, 16, 18],
        [7, 14, 18, 20],
        [8, 16, 20, 21],
        [8, 17, 22, 23],
        [9, 17, 22, 25],
        [10, 19, 24, 27],
        [12, 21, 24, 29],
        [12, 21, 26, 31],
        [12, 23, 28, 33],
        [13, 23, 28, 35],
        [14, 25, 28, 37],
        [15, 25, 30, 39],
        [16, 27, 30, 41],
        [17, 27, 32, 43],
        [18, 29, 34, 45],
        [19, 29, 36, 47],
        [19, 31, 36, 49],
        [20, 31, 38, 51],
        [21, 33, 38, 53],
        [22, 33, 40, 55],
        [24, 35, 40, 57],
        [25, 35, 42, 59],
        [26, 37, 42, 61]
      ];

      var TOTAL_CODEWORDS = [
        0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991,
        1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1954, 2084, 2218, 2356, 2498, 2644, 2794, 2948,
        3106, 3276, 3450, 3628, 3810
      ];

      function getRSBlocks(typeNumber, errorCorrectLevel) {
        var eccPerBlock = ECC_CODEWORDS_PER_BLOCK[typeNumber][errorCorrectLevel];
        var numBlocks = NUM_ERROR_CORRECTION_BLOCKS[typeNumber][errorCorrectLevel];
        var totalCodewords = TOTAL_CODEWORDS[typeNumber];
        var totalDataCodewords = totalCodewords - eccPerBlock * numBlocks;
        var dataCount = Math.floor(totalDataCodewords / numBlocks);
        var longerBlocks = totalDataCodewords % numBlocks;
        var list = [];
        for (var i = 0; i < numBlocks; i++) {
          var dataSize = dataCount + (i < longerBlocks ? 1 : 0);
          list.push(qrRSBlock(dataSize + eccPerBlock, dataSize));
        }
        return list;
      }

      var QRUtil = {
        PATTERN_POSITION_TABLE : [
          [],
          [6, 18],
          [6, 22],
          [6, 26],
          [6, 30],
          [6, 34],
          [6, 22, 38],
          [6, 24, 42],
          [6, 26, 46],
          [6, 28, 50],
          [6, 30, 54],
          [6, 32, 58],
          [6, 34, 62],
          [6, 26, 46, 66],
          [6, 26, 48, 70],
          [6, 26, 50, 74],
          [6, 30, 54, 78],
          [6, 30, 56, 82],
          [6, 30, 58, 86],
          [6, 34, 62, 90],
          [6, 28, 50, 72, 94],
          [6, 26, 50, 74, 98],
          [6, 30, 54, 78, 102],
          [6, 28, 54, 80, 106],
          [6, 32, 58, 84, 110],
          [6, 30, 58, 86, 114],
          [6, 34, 62, 90, 118],
          [6, 26, 50, 74, 98, 122],
          [6, 30, 54, 78, 102, 126],
          [6, 26, 52, 78, 104, 130],
          [6, 30, 56, 82, 108, 134],
          [6, 34, 60, 86, 112, 138],
          [6, 30, 58, 86, 114, 142],
          [6, 34, 62, 90, 118, 146],
          [6, 30, 54, 78, 102, 126, 150],
          [6, 24, 50, 76, 102, 128, 154],
          [6, 28, 54, 80, 106, 132, 158],
          [6, 32, 58, 84, 110, 136, 162],
          [6, 26, 54, 82, 110, 138, 166],
          [6, 30, 58, 86, 114, 142, 170]
        ],
        G15 : (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
        G18 : (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
        G15_MASK : (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1),
        getBCHTypeInfo : function(data) {
          var d = data << 10;
          while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
            d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15)));
          }
          return ((data << 10) | d) ^ QRUtil.G15_MASK;
        },
        getBCHTypeNumber : function(data) {
          var d = data << 12;
          while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
            d ^= (QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18)));
          }
          return (data << 12) | d;
        },
        getBCHDigit : function(data) {
          var digit = 0;
          while (data !== 0) {
            digit++;
            data >>>= 1;
          }
          return digit;
        },
        getPatternPosition : function(typeNumber) {
          return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
        },
        getMaskFunction : function(maskPattern) {
          switch (maskPattern) {
          case 0 : return function(i, j) { return (i + j) % 2 === 0; };
          case 1 : return function(i, j) { return i % 2 === 0; };
          case 2 : return function(i, j) { return j % 3 === 0; };
          case 3 : return function(i, j) { return (i + j) % 3 === 0; };
          case 4 : return function(i, j) { return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0; };
          case 5 : return function(i, j) { return ((i * j) % 2) + ((i * j) % 3) === 0; };
          case 6 : return function(i, j) { return (((i * j) % 2) + ((i * j) % 3)) % 2 === 0; };
          case 7 : return function(i, j) { return (((i + j) % 2) + ((i * j) % 3)) % 2 === 0; };
          default : throw new Error('bad maskPattern:' + maskPattern);
          }
        }
      };

      function QRBitBuffer() {
        this.buffer = [];
        this.length = 0;
      }
      QRBitBuffer.prototype = {
        get : function(index) {
          var bufIndex = Math.floor(index / 8);
          return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1;
        },
        put : function(num, length) {
          for (var i = 0; i < length; i++) {
            this.putBit(((num >>> (length - i - 1)) & 1) === 1);
          }
        },
        putBit : function(bit) {
          var bufIndex = Math.floor(this.length / 8);
          if (this.buffer.length <= bufIndex) {
            this.buffer.push(0);
          }
          if (bit) {
            this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
          }
          this.length++;
        }
      };

      function QRCodeModel(typeNumber, errorCorrectLevel) {
        this.typeNumber = typeNumber;
        this.errorCorrectLevel = errorCorrectLevel;
        this.modules = null;
        this.moduleCount = 0;
        this.dataCache = null;
        this.dataList = [];
      }

      QRCodeModel.prototype = {
        addData : function(data) {
          var newData = qr8BitByte(data);
          this.dataList.push(newData);
          this.dataCache = null;
        },
        isDark : function(row, col) {
          if (this.modules[row][col] === null) {
            return false;
          }
          return this.modules[row][col];
        },
        getModuleCount : function() {
          return this.moduleCount;
        },
        make : function() {
          if (this.typeNumber < 1) {
            this.typeNumber = 1;
          }
          this.makeImpl(false, this.getBestMaskPattern());
        },
        makeImpl : function(test, maskPattern) {
          this.moduleCount = this.typeNumber * 4 + 17;
          this.modules = new Array(this.moduleCount);
          for (var row = 0; row < this.moduleCount; row++) {
            this.modules[row] = new Array(this.moduleCount);
            for (var col = 0; col < this.moduleCount; col++) {
              this.modules[row][col] = null;
            }
          }
          this.setupPositionProbePattern(0, 0);
          this.setupPositionProbePattern(this.moduleCount - 7, 0);
          this.setupPositionProbePattern(0, this.moduleCount - 7);
          this.setupTimingPattern();
          if (this.typeNumber >= 2) {
            this.setupPositionAdjustPattern();
          }
          if (this.typeNumber >= 7) {
            this.setupTypeNumber(test);
          }
          this.setupTypeInfo(test, maskPattern);
          this.dataCache = this.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
          this.mapData(this.dataCache, maskPattern);
        },
        setupPositionProbePattern : function(row, col) {
          for (var r = -1; r <= 7; r++) {
            if (row + r <= -1 || this.moduleCount <= row + r) continue;
            for (var c = -1; c <= 7; c++) {
              if (col + c <= -1 || this.moduleCount <= col + c) continue;
              if ((0 <= r && r <= 6 && (c === 0 || c === 6)) || (0 <= c && c <= 6 && (r === 0 || r === 6)) || (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
                this.modules[row + r][col + c] = true;
              } else {
                this.modules[row + r][col + c] = false;
              }
            }
          }
        },
        getBestMaskPattern : function() {
          var minLostPoint = 0;
          var pattern = 0;
          for (var i = 0; i < 8; i++) {
            this.makeImpl(true, i);
            var lostPoint = QRUtil.getLostPoint(this);
            if (i === 0 || minLostPoint > lostPoint) {
              minLostPoint = lostPoint;
              pattern = i;
            }
          }
          return pattern;
        },
        setupTimingPattern : function() {
          for (var r = 8; r < this.moduleCount - 8; r++) {
            if (this.modules[r][6] !== null) continue;
            this.modules[r][6] = (r % 2 === 0);
          }
          for (var c = 8; c < this.moduleCount - 8; c++) {
            if (this.modules[6][c] !== null) continue;
            this.modules[6][c] = (c % 2 === 0);
          }
        },
        setupPositionAdjustPattern : function() {
          var pos = QRUtil.getPatternPosition(this.typeNumber);
          for (var i = 0; i < pos.length; i++) {
            for (var j = 0; j < pos.length; j++) {
              var row = pos[i];
              var col = pos[j];
              if (this.modules[row][col] !== null) continue;
              for (var r = -2; r <= 2; r++) {
                for (var c = -2; c <= 2; c++) {
                  if (r === -2 || r === 2 || c === -2 || c === 2 || (r === 0 && c === 0)) {
                    this.modules[row + r][col + c] = true;
                  } else {
                    this.modules[row + r][col + c] = false;
                  }
                }
              }
            }
          }
        },
        setupTypeNumber : function(test) {
          var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
          for (var i = 0; i < 18; i++) {
            var mod = (!test && ((bits >> i) & 1) === 1);
            var row = Math.floor(i / 3);
            var col = i % 3 + this.moduleCount - 8 - 3;
            this.modules[row][col] = mod;
            this.modules[col][row] = mod;
          }
        },
        setupTypeInfo : function(test, maskPattern) {
          var data = (this.errorCorrectLevel << 3) | maskPattern;
          var bits = QRUtil.getBCHTypeInfo(data);
          for (var i = 0; i < 15; i++) {
            var mod = (!test && ((bits >> i) & 1) === 1);
            if (i < 6) {
              this.modules[i][8] = mod;
            } else if (i < 8) {
              this.modules[i + 1][8] = mod;
            } else {
              this.modules[this.moduleCount - 15 + i][8] = mod;
            }
            if (i < 8) {
              this.modules[8][this.moduleCount - i - 1] = mod;
            } else if (i < 9) {
              this.modules[8][15 - i - 1 + 1] = mod;
            } else {
              this.modules[8][15 - i - 1] = mod;
            }
          }
          this.modules[this.moduleCount - 8][8] = !test;
        },
        mapData : function(data, maskPattern) {
          var inc = -1;
          var row = this.moduleCount - 1;
          var bitIndex = 7;
          var byteIndex = 0;
          for (var col = this.moduleCount - 1; col > 0; col -= 2) {
            if (col === 6) col--;
            while (true) {
              for (var c = 0; c < 2; c++) {
                if (this.modules[row][col - c] === null) {
                  var dark = false;
                  if (byteIndex < data.length) {
                    dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);
                  }
                  if (QRUtil.getMaskFunction(maskPattern)(row, col - c)) {
                    dark = !dark;
                  }
                  this.modules[row][col - c] = dark;
                  bitIndex--;
                  if (bitIndex === -1) {
                    byteIndex++;
                    bitIndex = 7;
                  }
                }
              }
              row += inc;
              if (row < 0 || this.moduleCount <= row) {
                row -= inc;
                inc = -inc;
                break;
              }
            }
          }
        },
        createData : function(typeNumber, errorCorrectLevel, dataList) {
          var rsBlocks = getRSBlocks(typeNumber, errorCorrectLevel);
          var buffer = new QRBitBuffer();
          for (var i = 0; i < dataList.length; i++) {
            var data = dataList[i];
            buffer.put(data.mode, 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
            data.write(buffer);
          }
          var totalDataCount = 0;
          for (i = 0; i < rsBlocks.length; i++) {
            totalDataCount += rsBlocks[i].dataCount;
          }
          if (buffer.length + 4 <= totalDataCount * 8) {
            buffer.put(0, 4);
          }
          while (buffer.length % 8 !== 0) {
            buffer.putBit(false);
          }
          var dataBytes = [];
          while (buffer.length / 8 > totalDataCount) {
            throw new Error('code length overflow.');
          }
          for (i = 0; i < buffer.length / 8; i++) {
            dataBytes.push(buffer.buffer[i]);
          }
          var paddingBytes = [0xec, 0x11];
          var index = 0;
          while (dataBytes.length < totalDataCount) {
            dataBytes.push(paddingBytes[index % 2]);
            index++;
          }
          return createBytes(buffer, rsBlocks);
        },
        createSvgTag: function(opts) {
          opts = opts || {};
          var cellSize = opts.cellSize || 2;
          var margin = opts.margin || 4;
          var size = this.modules.length;
          var svg = ["<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 " + (size + margin * 2) + " " + (size + margin * 2) + "' shape-rendering='crispEdges'>"];
          svg.push("<rect width='100%' height='100%' fill='white'/>");
          var path = [];
          for (var r = 0; r < size; r++) {
            for (var c = 0; c < size; c++) {
              if (this.modules[r][c]) {
                path.push('M' + (c + margin) + ' ' + (r + margin) + 'h1v1h-1z');
              }
            }
          }
          svg.push("<path stroke='none' fill='black' d='" + path.join('') + "'/>");
          svg.push('</svg>');
          return svg.join('');
        }
      };

      function qr8BitByte(data) {
        var buffer = [];
        for (var i = 0; i < data.length; i++) {
          buffer.push(data.charCodeAt(i));
        }
        return {
          mode : mode8bitByte.mode,
          getLength : function() {
            return buffer.length;
          },
          write : function(bitBuffer) {
            for (var i = 0; i < buffer.length; i++) {
              bitBuffer.put(buffer[i], 8);
            }
          }
        };
      }

      QRUtil.getLengthInBits = function(mode, type) {
        if (1 <= type && type < 10) {
          switch(mode) {
          case 4 : return 8;
          default : throw new Error('mode:' + mode);
          }
        } else if (type < 27) {
          switch(mode) {
          case 4 : return 16;
          default : throw new Error('mode:' + mode);
          }
        } else if (type < 41) {
          switch(mode) {
          case 4 : return 16;
          default : throw new Error('mode:' + mode);
          }
        } else {
          throw new Error('type:' + type);
        }
      };

      QRUtil.getLostPoint = function(qrCode) {
        var moduleCount = qrCode.getModuleCount();
        var lostPoint = 0;
        for (var row = 0; row < moduleCount; row++) {
          for (var col = 0; col < moduleCount; col++) {
            var sameCount = 0;
            var dark = qrCode.isDark(row, col);
            for (var r = -1; r <= 1; r++) {
              if (row + r < 0 || moduleCount <= row + r) {
                continue;
              }
              for (var c = -1; c <= 1; c++) {
                if (col + c < 0 || moduleCount <= col + c) {
                  continue;
                }
                if (r === 0 && c === 0) {
                  continue;
                }
                if (dark === qrCode.isDark(row + r, col + c)) {
                  sameCount++;
                }
              }
            }
            if (sameCount > 5) {
              lostPoint += (3 + sameCount - 5);
            }
          }
        }
        for (row = 0; row < moduleCount - 1; row++) {
          for (col = 0; col < moduleCount - 1; col++) {
            var count = 0;
            if (qrCode.isDark(row, col)) count++;
            if (qrCode.isDark(row + 1, col)) count++;
            if (qrCode.isDark(row, col + 1)) count++;
            if (qrCode.isDark(row + 1, col + 1)) count++;
            if (count === 0 || count === 4) {
              lostPoint += 3;
            }
          }
        }
        for (row = 0; row < moduleCount; row++) {
          for (col = 0; col < moduleCount - 6; col++) {
            if (qrCode.isDark(row, col)
                && !qrCode.isDark(row, col + 1)
                && qrCode.isDark(row, col + 2)
                && qrCode.isDark(row, col + 3)
                && qrCode.isDark(row, col + 4)
                && !qrCode.isDark(row, col + 5)
                && qrCode.isDark(row, col + 6)) {
              lostPoint += 40;
            }
          }
        }
        for (col = 0; col < moduleCount; col++) {
          for (row = 0; row < moduleCount - 6; row++) {
            if (qrCode.isDark(row, col)
                && !qrCode.isDark(row + 1, col)
                && qrCode.isDark(row + 2, col)
                && qrCode.isDark(row + 3, col)
                && qrCode.isDark(row + 4, col)
                && !qrCode.isDark(row + 5, col)
                && qrCode.isDark(row + 6, col)) {
              lostPoint += 40;
            }
          }
        }
        var darkCount = 0;
        for (col = 0; col < moduleCount; col++) {
          for (row = 0; row < moduleCount; row++) {
            if (qrCode.isDark(row, col)) {
              darkCount++;
            }
          }
        }
        var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
        lostPoint += ratio * 10;
        return lostPoint;
      };

      function createBytes(buffer, rsBlocks) {
        var offset = 0;
        var maxDcCount = 0;
        var maxEcCount = 0;
        var dcdata = [];
        var ecdata = [];
        for (var r = 0; r < rsBlocks.length; r++) {
          var dcCount = rsBlocks[r].dataCount;
          var ecCount = rsBlocks[r].totalCount - dcCount;
          maxDcCount = Math.max(maxDcCount, dcCount);
          maxEcCount = Math.max(maxEcCount, ecCount);
          dcdata[r] = new Array(dcCount);
          for (var i = 0; i < dcCount; i++) {
            dcdata[r][i] = buffer.buffer[offset + i];
          }
          offset += dcCount;
          var rsPoly = qrPolynomial([1], 0);
          for (i = 0; i < ecCount; i++) {
            rsPoly = rsPoly.multiply(qrPolynomial([1, QRMath.gexp(i)], 0));
          }
          var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);
          var modPoly = rawPoly.mod(rsPoly);
          ecdata[r] = new Array(rsPoly.getLength() - 1);
          for (i = 0; i < ecdata[r].length; i++) {
            var modIndex = i + modPoly.getLength() - ecdata[r].length;
            ecdata[r][i] = (modIndex >= 0) ? modPoly.get(modIndex) : 0;
          }
        }
        var totalCodeCount = 0;
        for (r = 0; r < rsBlocks.length; r++) {
          totalCodeCount += rsBlocks[r].totalCount;
        }
        var data = new Array(totalCodeCount);
        var index = 0;
        for (i = 0; i < maxDcCount; i++) {
          for (r = 0; r < rsBlocks.length; r++) {
            if (i < rsBlocks[r].dataCount) {
              data[index++] = dcdata[r][i];
            }
          }
        }
        for (i = 0; i < maxEcCount; i++) {
          for (r = 0; r < rsBlocks.length; r++) {
            if (i < rsBlocks[r].totalCount - rsBlocks[r].dataCount) {
              data[index++] = ecdata[r][i];
            }
          }
        }
        return data;
      }

      window.qrcode = function(typeNumber, errorCorrectLevel) {
        var levels = { L: 0, M: 1, Q: 2, H: 3 };
        var level = errorCorrectLevel;
        if (typeof level === 'string') {
          level = levels[level.toUpperCase()] !== undefined ? levels[level.toUpperCase()] : levels.M;
        }
        if (typeof level !== 'number' || level < 0 || level > 3) {
          level = levels.M;
        }
        var initialVersion = typeNumber < 1 ? 1 : typeNumber;
        var qr = new QRCodeModel(initialVersion, level);
        return {
          addData: function(data) {
            qr.addData(data);
          },
          make: function() {
            if (typeNumber < 1) {
              var version = 1;
              while (version <= 40) {
                try {
                  qr.typeNumber = version;
                  qr.dataCache = null;
                  qr.make();
                  break;
                } catch (error) {
                  if (error && typeof error.message === 'string' && error.message.indexOf('code length overflow') >= 0) {
                    version++;
                    continue;
                  }
                  throw error;
                }
              }
              if (version > 40) {
                throw new Error('code length overflow.');
              }
            } else {
              qr.make();
            }
          },
          createSvgTag: function(options) {
            return qr.createSvgTag(options);
          }
        };
      };
      };
    })();
  </script>
</body>
</html>
