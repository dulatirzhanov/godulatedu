
+<!DOCTYPE html>
+<html lang="ru">
+<head>
+  <meta charset="utf-8">
+  <meta name="viewport" content="width=device-width, initial-scale=1">
+  <title>UTM Конструктор — dulatedu</title>
+  <style>
+    :root {
+      color-scheme: light dark;
+      --bg: #f5f5f5;
+      --card: #ffffffcc;
+      --text: #1f2933;
+      --muted: #6b7280;
+      --accent: #2563eb;
+      --accent-dark: #1d4ed8;
+      --border: #d1d5db;
+      --radius: 14px;
+      --shadow: 0 24px 48px rgba(15, 23, 42, 0.12);
+    }
+
+    * {
+      box-sizing: border-box;
+    }
+
+    body {
+      margin: 0;
+      min-height: 100vh;
+      font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;
+      background: radial-gradient(120% 120% at 50% 10%, #dbeafe 0%, var(--bg) 50%, #f9fafb 100%);
+      color: var(--text);
+      display: flex;
+      align-items: center;
+      justify-content: center;
+      padding: 32px 16px 64px;
+    }
+
+    main {
+      width: min(880px, 100%);
+      background: var(--card);
+      border-radius: var(--radius);
+      box-shadow: var(--shadow);
+      padding: 32px clamp(20px, 4vw, 48px) 40px;
+      backdrop-filter: blur(20px);
+    }
+
+    header {
+      text-align: center;
+      margin-bottom: 32px;
+    }
+
+    h1 {
+      margin: 0 0 8px;
+      font-size: clamp(1.7rem, 4vw, 2.4rem);
+      font-weight: 700;
+      letter-spacing: -0.02em;
+    }
+
+    p.lead {
+      margin: 0;
+      color: var(--muted);
+      font-size: clamp(1rem, 3vw, 1.1rem);
+    }
+
+    form {
+      display: grid;
+      gap: 16px;
+      margin-bottom: 24px;
+    }
+
+    .field {
+      display: flex;
+      flex-direction: column;
+      gap: 6px;
+    }
+
+    label {
+      font-weight: 600;
+      font-size: 0.95rem;
+    }
+
+    input[type="text"],
+    select,
+    textarea {
+      width: 100%;
+      padding: 12px 14px;
+      font-size: 1rem;
+      border-radius: 10px;
+      border: 1px solid var(--border);
+      background: rgba(255, 255, 255, 0.9);
+      color: inherit;
+      transition: border 0.2s, box-shadow 0.2s;
+    }
+
+    input[type="text"]:focus,
+    select:focus,
+    textarea:focus,
+    button:focus-visible {
+      outline: none;
+      border-color: var(--accent);
+      box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 25%, transparent);
+    }
+
+    .inputs-grid {
+      display: grid;
+      gap: 16px;
+      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+    }
+
+    .chips {
+      display: flex;
+      flex-wrap: wrap;
+      gap: 8px;
+      margin-bottom: 12px;
+    }
+
+    .chip {
+      border: 1px solid color-mix(in srgb, var(--accent) 35%, transparent);
+      border-radius: 999px;
+      background: color-mix(in srgb, var(--accent) 12%, white 88%);
+      color: var(--accent-dark);
+      padding: 6px 14px;
+      font-size: 0.9rem;
+      cursor: pointer;
+      transition: transform 0.15s, box-shadow 0.15s;
+    }
+
+    .chip:hover,
+    .chip:focus-visible {
+      transform: translateY(-1px);
+      box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25);
+    }
+
+    .actions {
+      display: flex;
+      flex-wrap: wrap;
+      gap: 12px;
+      margin-top: 8px;
+    }
+
+    button {
+      border: none;
+      border-radius: 10px;
+      padding: 12px 20px;
+      font-size: 1rem;
+      font-weight: 600;
+      cursor: pointer;
+      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s;
+      display: inline-flex;
+      align-items: center;
+      gap: 8px;
+      justify-content: center;
+    }
+
+    .btn-primary {
+      background: linear-gradient(135deg, var(--accent), color-mix(in srgb, var(--accent) 70%, white 30%));
+      color: white;
+      box-shadow: 0 14px 24px rgba(37, 99, 235, 0.28);
+    }
+
+    .btn-primary:hover,
+    .btn-primary:focus-visible {
+      transform: translateY(-1px);
+      box-shadow: 0 18px 32px rgba(37, 99, 235, 0.32);
+    }
+
+    .btn-secondary {
+      background: rgba(15, 23, 42, 0.06);
+      color: var(--text);
+      border: 1px solid rgba(15, 23, 42, 0.08);
+    }
+
+    .btn-secondary:hover,
+    .btn-secondary:focus-visible {
+      transform: translateY(-1px);
+      box-shadow: 0 10px 20px rgba(15, 23, 42, 0.12);
+    }
+
+    .result {
+      margin-top: 24px;
+      display: grid;
+      gap: 12px;
+    }
+
+    .result textarea {
+      min-height: 72px;
+      resize: vertical;
+    }
+
+    .qr-wrapper {
+      display: grid;
+      gap: 12px;
+      justify-items: start;
+    }
+
+    canvas {
+      image-rendering: pixelated;
+    }
+
+    .status {
+      min-height: 1.2em;
+      font-size: 0.9rem;
+      color: var(--muted);
+    }
+
+    .error {
+      color: #dc2626;
+      font-weight: 600;
+    }
+
+    @media (max-width: 640px) {
+      body {
+        padding: 16px;
+      }
+
+      main {
+        padding: 24px 18px 32px;
+      }
+
+      .actions {
+        flex-direction: column;
+      }
+
+      button {
+        width: 100%;
+      }
+
+      .qr-wrapper {
+        justify-items: stretch;
+      }
+
+      .qr-wrapper canvas {
+        margin: 0 auto;
+      }
+    }
+  </style>
+</head>
+<body>
+  <main>
+    <header>
+      <h1>UTM Конструктор</h1>
+      <p class="lead">Создавайте UTM-ссылки для dulatedu всего за несколько кликов.</p>
+    </header>
+
+    <section aria-labelledby="presets-heading">
+      <h2 id="presets-heading" style="font-size:1.05rem;margin-bottom:12px;">Готовые сценарии</h2>
+      <div class="chips" role="list">
+        <button
+          class="chip"
+          type="button"
+          data-source="instagram"
+          data-medium="social"
+          data-campaign="bio"
+          data-content="instagram_profile"
+        >Instagram био</button>
+        <button
+          class="chip"
+          type="button"
+          data-source="linkedin"
+          data-medium="social"
+          data-campaign="bio"
+          data-content="linkedin_profile"
+        >LinkedIn био</button>
+        <button
+          class="chip"
+          type="button"
+          data-source="telegram"
+          data-medium="social"
+          data-campaign="bio"
+          data-content="telegram_profile"
+        >Telegram био</button>
+        <button
+          class="chip"
+          type="button"
+          data-source="whatsapp"
+          data-medium="social"
+          data-campaign="bio"
+          data-content="whatsapp_profile"
+        >WhatsApp био</button>
+        <button
+          class="chip"
+          type="button"
+          data-source="event"
+          data-medium="qr"
+          data-campaign="nu_visit_2025"
+          data-content="event_badge"
+        >Event QR (nu_visit_2025)</button>
+      </div>
+    </section>
+
+    <form id="utmForm" novalidate>
+      <div class="field">
+        <label for="baseUrl">Базовая ссылка</label>
+        <input id="baseUrl" name="baseUrl" type="text" placeholder="https://dulatedu.com/" autocomplete="url" required>
+        <span id="baseError" class="status"></span>
+      </div>
+
+      <div class="inputs-grid">
+        <div class="field">
+          <label for="utmSource">utm_source</label>
+          <select id="utmSource" name="utm_source" required>
+            <option value="">Выберите источник</option>
+            <option value="instagram">instagram</option>
+            <option value="linkedin">linkedin</option>
+            <option value="telegram">telegram</option>
+            <option value="whatsapp">whatsapp</option>
+            <option value="facebook">facebook</option>
+            <option value="email">email</option>
+            <option value="event">event</option>
+            <option value="other">other</option>
+          </select>
+        </div>
+        <div class="field">
+          <label for="utmMedium">utm_medium</label>
+          <select id="utmMedium" name="utm_medium" required>
+            <option value="">Выберите канал</option>
+            <option value="social">social</option>
+            <option value="referral">referral</option>
+            <option value="cpc">cpc</option>
+            <option value="email">email</option>
+            <option value="qr">qr</option>
+            <option value="banner">banner</option>
+          </select>
+        </div>
+        <div class="field">
+          <label for="utmCampaign">utm_campaign</label>
+          <input id="utmCampaign" name="utm_campaign" type="text" placeholder="пример: spring_launch" required>
+        </div>
+        <div class="field">
+          <label for="utmContent">utm_content <span style="color:var(--muted);font-weight:400;">(необязательно)</span></label>
+          <input id="utmContent" name="utm_content" type="text" placeholder="пример: hero_button">
+        </div>
+        <div class="field">
+          <label for="utmTerm">utm_term <span style="color:var(--muted);font-weight:400;">(необязательно)</span></label>
+          <input id="utmTerm" name="utm_term" type="text" placeholder="пример: brand_keyword">
+        </div>
+      </div>
+
+      <div class="actions">
+        <button type="submit" class="btn-primary">Сгенерировать ссылку</button>
+        <button type="button" id="copyBtn" class="btn-secondary">Скопировать</button>
+        <button type="button" id="qrBtn" class="btn-secondary">Показать QR</button>
+      </div>
+    </form>
+
+    <section class="result" aria-live="polite">
+      <div class="field">
+        <label for="resultUrl">Готовая ссылка</label>
+        <textarea id="resultUrl" readonly spellcheck="false"></textarea>
+      </div>
+      <div class="qr-wrapper">
+        <div id="qrCode" aria-label="QR код" role="img"></div>
+        <span id="statusMessage" class="status" role="status" aria-live="polite"></span>
+      </div>
+    </section>
+  </main>
+
+  <script>
+    (function () {
+      const storageKey = 'utm_builder_state_v1';
+      const defaultState = {
+        baseUrl: 'https://dulatedu.com/',
+        utm_source: 'instagram',
+        utm_medium: 'social',
+        utm_campaign: 'bio',
+        utm_content: '',
+        utm_term: ''
+      };
+
+      const form = document.getElementById('utmForm');
+      const baseInput = document.getElementById('baseUrl');
+      const sourceSelect = document.getElementById('utmSource');
+      const mediumSelect = document.getElementById('utmMedium');
+      const campaignInput = document.getElementById('utmCampaign');
+      const contentInput = document.getElementById('utmContent');
+      const termInput = document.getElementById('utmTerm');
+      const resultField = document.getElementById('resultUrl');
+      const copyBtn = document.getElementById('copyBtn');
+      const qrBtn = document.getElementById('qrBtn');
+      const qrContainer = document.getElementById('qrCode');
+      const status = document.getElementById('statusMessage');
+      const baseError = document.getElementById('baseError');
+
+      function ensureScheme(url) {
+        if (!url) return url;
+        return /^https?:\/\//i.test(url) ? url : 'https://' + url;
+      }
+
+      function isValidHttpUrl(value) {
+        try {
+          const parsed = new URL(value);
+          return parsed.protocol === 'http:' || parsed.protocol === 'https:';
+        } catch (error) {
+          return false;
+        }
+      }
+
+      function collectState() {
+        return {
+          baseUrl: baseInput.value.trim(),
+          utm_source: sourceSelect.value,
+          utm_medium: mediumSelect.value,
+          utm_campaign: campaignInput.value.trim(),
+          utm_content: contentInput.value.trim(),
+          utm_term: termInput.value.trim()
+        };
+      }
+
+      function persistState() {
+        const state = collectState();
+        try {
+          localStorage.setItem(storageKey, JSON.stringify(state));
+        } catch (error) {
+          console.warn('Не удалось сохранить состояние', error);
+        }
+      }
+
+      function hydrateState() {
+        try {
+          const raw = localStorage.getItem(storageKey);
+          if (!raw) throw new Error('no state');
+          const data = { ...defaultState, ...JSON.parse(raw) };
+          baseInput.value = data.baseUrl || defaultState.baseUrl;
+          sourceSelect.value = data.utm_source || '';
+          mediumSelect.value = data.utm_medium || '';
+          campaignInput.value = data.utm_campaign || '';
+          contentInput.value = data.utm_content || '';
+          termInput.value = data.utm_term || '';
+        } catch (error) {
+          baseInput.value = defaultState.baseUrl;
+          sourceSelect.value = defaultState.utm_source;
+          mediumSelect.value = defaultState.utm_medium;
+          campaignInput.value = defaultState.utm_campaign;
+          contentInput.value = defaultState.utm_content;
+          termInput.value = defaultState.utm_term;
+        }
+      }
+
+      function resetStatus(message, isError) {
+        status.textContent = message || '';
+        status.classList.toggle('error', Boolean(isError));
+        baseError.textContent = '';
+        baseError.classList.remove('error');
+      }
+
+      function showBaseError(message) {
+        baseError.textContent = message;
+        baseError.classList.add('error');
+      }
+
+      function clearQr() {
+        while (qrContainer.firstChild) {
+          qrContainer.removeChild(qrContainer.firstChild);
+        }
+      }
+
+      function buildUrl() {
+        const rawBase = ensureScheme(baseInput.value.trim());
+        if (!rawBase) {
+          showBaseError('Укажите базовую ссылку.');
+          return '';
+        }
+
+        if (!isValidHttpUrl(rawBase)) {
+          showBaseError('Введите корректный адрес с http или https.');
+          return '';
+        }
+
+        baseInput.value = rawBase;
+        const url = new URL(rawBase);
+        const params = new URLSearchParams();
+
+        const source = sourceSelect.value;
+        const medium = mediumSelect.value;
+        const campaign = campaignInput.value.trim();
+        const content = contentInput.value.trim();
+        const term = termInput.value.trim();
+
+        if (!source || !medium || !campaign) {
+          showBaseError('Заполните обязательные поля utm_source, utm_medium и utm_campaign.');
+          return '';
+        }
+
+        params.set('utm_source', source);
+        params.set('utm_medium', medium);
+        params.set('utm_campaign', campaign);
+        if (content) params.set('utm_content', content);
+        if (term) params.set('utm_term', term);
+
+        url.search = params.toString();
+        const finalUrl = url.toString();
+        resultField.value = finalUrl;
+        resetStatus('Ссылка готова.');
+        persistState();
+        return finalUrl;
+      }
+
+      form.addEventListener('submit', function (event) {
+        event.preventDefault();
+        resetStatus('');
+        clearQr();
+        const url = buildUrl();
+        if (url) {
+          status.textContent = 'Ссылка сгенерирована.';
+        }
+      });
+
+      [baseInput, sourceSelect, mediumSelect, campaignInput, contentInput, termInput].forEach(function (el) {
+        el.addEventListener('input', function () {
+          baseError.textContent = '';
+          baseError.classList.remove('error');
+        });
+        el.addEventListener('change', persistState);
+        el.addEventListener('blur', persistState);
+      });
+
+      copyBtn.addEventListener('click', function () {
+        const url = resultField.value.trim() || buildUrl();
+        if (!url) {
+          resetStatus('Сначала сформируйте ссылку.', true);
+          return;
+        }
+        navigator.clipboard.writeText(url).then(function () {
+          resetStatus('Ссылка скопирована в буфер обмена.');
+        }, function () {
+          resetStatus('Не удалось скопировать ссылку.', true);
+        });
+      });
+
+      qrBtn.addEventListener('click', function () {
+        const url = resultField.value.trim() || buildUrl();
+        if (!url) {
+          resetStatus('Сначала сформируйте ссылку.', true);
+          return;
+        }
+        clearQr();
+        try {
+          const qr = qrcode(0, 'M');
+          qr.addData(url);
+          qr.make();
+          qrContainer.innerHTML = qr.createSvgTag({ scalable: true, margin: 2 });
+          qrContainer.firstChild.setAttribute('width', '180');
+          qrContainer.firstChild.setAttribute('height', '180');
+          qrContainer.firstChild.setAttribute('role', 'img');
+          qrContainer.firstChild.setAttribute('aria-label', 'QR код для созданной ссылки');
+          resetStatus('QR-код готов к скачиванию или показу.');
+        } catch (error) {
+          clearQr();
+          const message = error && error.message ? error.message : 'Неизвестная ошибка';
+          resetStatus('Не удалось создать QR: ' + message, true);
+        }
+      });
+
+      document.querySelectorAll('.chip').forEach(function (chip) {
+        chip.addEventListener('click', function () {
+          const presetBase = chip.dataset.base;
+          if (presetBase) {
+            baseInput.value = presetBase;
+          }
+          if (chip.dataset.source) sourceSelect.value = chip.dataset.source;
+          if (chip.dataset.medium) mediumSelect.value = chip.dataset.medium;
+          if (chip.dataset.campaign) campaignInput.value = chip.dataset.campaign;
+          contentInput.value = chip.dataset.content || '';
+          termInput.value = chip.dataset.term || '';
+          clearQr();
+          resultField.value = '';
+          resetStatus('Применен пресет «' + chip.textContent.trim() + '».');
+          persistState();
+        });
+      });
+
+      hydrateState();
+      buildUrl();
+    })();
+
+    /*! qrcode.js v1.0.0 (minimal build) | MIT License | Kazuhiko Arase */
+    (function() {
+      var mode8bitByte = {
+        mode: 4,
+        getLength: function(buffer) {
+          return buffer.length;
+        },
+        write: function(buffer, bitBuffer) {
+          for (var i = 0; i < buffer.length; i++) {
+            bitBuffer.put(buffer.charCodeAt(i), 8);
+          }
+        }
+      };
+
+      function qrPolynomial(num, shift) {
+        if (typeof num.length === 'undefined') throw new Error(num.length + '/' + shift);
+        var offset = 0;
+        while (offset < num.length && num[offset] === 0) {
+          offset++;
+        }
+        var _num = new Array(num.length - offset + shift);
+        for (var i = 0; i < num.length - offset; i++) {
+          _num[i] = num[i + offset];
+        }
+        return {
+          get : function(index) {
+            return _num[index];
+          },
+          getLength : function() {
+            return _num.length;
+          },
+          multiply : function(e) {
+            var num = new Array(this.getLength() + e.getLength() - 1);
+            for (var i = 0; i < this.getLength(); i++) {
+              for (var j = 0; j < e.getLength(); j++) {
+                num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
+              }
+            }
+            return qrPolynomial(num, 0);
+          },
+          mod : function(e) {
+            if (this.getLength() - e.getLength() < 0) {
+              return this;
+            }
+            var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
+            var num = new Array(this.getLength());
+            for (var i = 0; i < this.getLength(); i++) {
+              num[i] = this.get(i);
+            }
+            for (var j = 0; j < e.getLength(); j++) {
+              num[j] ^= QRMath.gexp(QRMath.glog(e.get(j)) + ratio);
+            }
+            return qrPolynomial(num, 0).mod(e);
+          }
+        };
+      }
+
+      var QRMath = {
+        glog : function(n) {
+          if (n < 1) { throw new Error('glog(' + n + ')'); }
+          return QRMath.LOG_TABLE[n];
+        },
+        gexp : function(n) {
+          while (n < 0) { n += 255; }
+          while (n >= 256) { n -= 255; }
+          return QRMath.EXP_TABLE[n];
+        },
+        EXP_TABLE : new Array(256),
+        LOG_TABLE : new Array(256)
+      };
+
+      for (var i = 0; i < 8; i++) {
+        QRMath.EXP_TABLE[i] = 1 << i;
+      }
+      for (i = 8; i < 256; i++) {
+        QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
+      }
+      for (i = 0; i < 255; i++) {
+        QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
+      }
+
+      function qrRSBlock(totalCount, dataCount) {
+        return { totalCount: totalCount, dataCount: dataCount };
+      }
+
+      var ECC_CODEWORDS_PER_BLOCK = [
+        null,
+        [7, 10, 13, 17],
+        [10, 16, 22, 28],
+        [15, 26, 36, 44],
+        [20, 36, 52, 64],
+        [26, 48, 72, 88],
+        [36, 64, 96, 112],
+        [40, 72, 108, 130],
+        [48, 88, 132, 156],
+        [60, 110, 160, 192],
+        [72, 130, 192, 224],
+        [80, 150, 224, 264],
+        [96, 176, 260, 308],
+        [104, 198, 288, 352],
+        [120, 216, 320, 384],
+        [132, 240, 360, 432],
+        [144, 280, 408, 480],
+        [168, 308, 448, 532],
+        [180, 338, 504, 588],
+        [196, 364, 546, 650],
+        [224, 416, 600, 700],
+        [224, 442, 644, 750],
+        [252, 476, 690, 816],
+        [270, 504, 750, 900],
+        [300, 560, 810, 960],
+        [312, 588, 870, 1050],
+        [336, 644, 952, 1110],
+        [360, 700, 1020, 1200],
+        [390, 728, 1050, 1260],
+        [420, 784, 1140, 1350],
+        [450, 812, 1200, 1440],
+        [480, 868, 1290, 1530],
+        [510, 924, 1350, 1620],
+        [540, 980, 1440, 1710],
+        [570, 1036, 1530, 1800],
+        [570, 1064, 1590, 1890],
+        [600, 1120, 1680, 1980],
+        [630, 1204, 1770, 2100],
+        [660, 1260, 1860, 2220],
+        [720, 1316, 1950, 2310],
+        [750, 1372, 2040, 2430]
+      ];
+
+      var NUM_ERROR_CORRECTION_BLOCKS = [
+        null,
+        [1, 1, 1, 1],
+        [1, 1, 1, 1],
+        [1, 1, 2, 2],
+        [1, 2, 2, 4],
+        [1, 2, 2, 2],
+        [2, 4, 4, 4],
+        [2, 4, 6, 5],
+        [2, 4, 6, 6],
+        [2, 5, 8, 8],
+        [4, 5, 8, 8],
+        [4, 5, 8, 11],
+        [4, 8, 10, 11],
+        [4, 9, 12, 11],
+        [4, 9, 12, 12],
+        [6, 10, 12, 12],
+        [6, 10, 14, 14],
+        [6, 11, 14, 16],
+        [6, 13, 16, 18],
+        [7, 14, 18, 20],
+        [8, 16, 20, 21],
+        [8, 17, 22, 23],
+        [9, 17, 22, 25],
+        [10, 19, 24, 27],
+        [12, 21, 24, 29],
+        [12, 21, 26, 31],
+        [12, 23, 28, 33],
+        [13, 23, 28, 35],
+        [14, 25, 28, 37],
+        [15, 25, 30, 39],
+        [16, 27, 30, 41],
+        [17, 27, 32, 43],
+        [18, 29, 34, 45],
+        [19, 29, 36, 47],
+        [19, 31, 36, 49],
+        [20, 31, 38, 51],
+        [21, 33, 38, 53],
+        [22, 33, 40, 55],
+        [24, 35, 40, 57],
+        [25, 35, 42, 59],
+        [26, 37, 42, 61]
+      ];
+
+      var TOTAL_CODEWORDS = [
+        0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991,
+        1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1954, 2084, 2218, 2356, 2498, 2644, 2794, 2948,
+        3106, 3276, 3450, 3628, 3810
+      ];
+
+      function getRSBlocks(typeNumber, errorCorrectLevel) {
+        var eccPerBlock = ECC_CODEWORDS_PER_BLOCK[typeNumber][errorCorrectLevel];
+        var numBlocks = NUM_ERROR_CORRECTION_BLOCKS[typeNumber][errorCorrectLevel];
+        var totalCodewords = TOTAL_CODEWORDS[typeNumber];
+        var totalDataCodewords = totalCodewords - eccPerBlock * numBlocks;
+        var dataCount = Math.floor(totalDataCodewords / numBlocks);
+        var longerBlocks = totalDataCodewords % numBlocks;
+        var list = [];
+        for (var i = 0; i < numBlocks; i++) {
+          var dataSize = dataCount + (i < longerBlocks ? 1 : 0);
+          list.push(qrRSBlock(dataSize + eccPerBlock, dataSize));
+        }
+        return list;
+      }
+
+      var QRUtil = {
+        PATTERN_POSITION_TABLE : [
+          [],
+          [6, 18],
+          [6, 22],
+          [6, 26],
+          [6, 30],
+          [6, 34],
+          [6, 22, 38],
+          [6, 24, 42],
+          [6, 26, 46],
+          [6, 28, 50],
+          [6, 30, 54],
+          [6, 32, 58],
+          [6, 34, 62],
+          [6, 26, 46, 66],
+          [6, 26, 48, 70],
+          [6, 26, 50, 74],
+          [6, 30, 54, 78],
+          [6, 30, 56, 82],
+          [6, 30, 58, 86],
+          [6, 34, 62, 90],
+          [6, 28, 50, 72, 94],
+          [6, 26, 50, 74, 98],
+          [6, 30, 54, 78, 102],
+          [6, 28, 54, 80, 106],
+          [6, 32, 58, 84, 110],
+          [6, 30, 58, 86, 114],
+          [6, 34, 62, 90, 118],
+          [6, 26, 50, 74, 98, 122],
+          [6, 30, 54, 78, 102, 126],
+          [6, 26, 52, 78, 104, 130],
+          [6, 30, 56, 82, 108, 134],
+          [6, 34, 60, 86, 112, 138],
+          [6, 30, 58, 86, 114, 142],
+          [6, 34, 62, 90, 118, 146],
+          [6, 30, 54, 78, 102, 126, 150],
+          [6, 24, 50, 76, 102, 128, 154],
+          [6, 28, 54, 80, 106, 132, 158],
+          [6, 32, 58, 84, 110, 136, 162],
+          [6, 26, 54, 82, 110, 138, 166],
+          [6, 30, 58, 86, 114, 142, 170]
+        ],
+        G15 : (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
+        G18 : (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
+        G15_MASK : (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1),
+        getBCHTypeInfo : function(data) {
+          var d = data << 10;
+          while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
+            d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15)));
+          }
+          return ((data << 10) | d) ^ QRUtil.G15_MASK;
+        },
+        getBCHTypeNumber : function(data) {
+          var d = data << 12;
+          while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
+            d ^= (QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18)));
+          }
+          return (data << 12) | d;
+        },
+        getBCHDigit : function(data) {
+          var digit = 0;
+          while (data !== 0) {
+            digit++;
+            data >>>= 1;
+          }
+          return digit;
+        },
+        getPatternPosition : function(typeNumber) {
+          return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
+        },
+        getMaskFunction : function(maskPattern) {
+          switch (maskPattern) {
+          case 0 : return function(i, j) { return (i + j) % 2 === 0; };
+          case 1 : return function(i, j) { return i % 2 === 0; };
+          case 2 : return function(i, j) { return j % 3 === 0; };
+          case 3 : return function(i, j) { return (i + j) % 3 === 0; };
+          case 4 : return function(i, j) { return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0; };
+          case 5 : return function(i, j) { return ((i * j) % 2) + ((i * j) % 3) === 0; };
+          case 6 : return function(i, j) { return (((i * j) % 2) + ((i * j) % 3)) % 2 === 0; };
+          case 7 : return function(i, j) { return (((i + j) % 2) + ((i * j) % 3)) % 2 === 0; };
+          default : throw new Error('bad maskPattern:' + maskPattern);
+          }
+        }
+      };
+
+      function QRBitBuffer() {
+        this.buffer = [];
+        this.length = 0;
+      }
+      QRBitBuffer.prototype = {
+        get : function(index) {
+          var bufIndex = Math.floor(index / 8);
+          return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1;
+        },
+        put : function(num, length) {
+          for (var i = 0; i < length; i++) {
+            this.putBit(((num >>> (length - i - 1)) & 1) === 1);
+          }
+        },
+        putBit : function(bit) {
+          var bufIndex = Math.floor(this.length / 8);
+          if (this.buffer.length <= bufIndex) {
+            this.buffer.push(0);
+          }
+          if (bit) {
+            this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
+          }
+          this.length++;
+        }
+      };
+
+      function QRCodeModel(typeNumber, errorCorrectLevel) {
+        this.typeNumber = typeNumber;
+        this.errorCorrectLevel = errorCorrectLevel;
+        this.modules = null;
+        this.moduleCount = 0;
+        this.dataCache = null;
+        this.dataList = [];
+      }
+
+      QRCodeModel.prototype = {
+        addData : function(data) {
+          var newData = qr8BitByte(data);
+          this.dataList.push(newData);
+          this.dataCache = null;
+        },
+        isDark : function(row, col) {
+          if (this.modules[row][col] === null) {
+            return false;
+          }
+          return this.modules[row][col];
+        },
+        getModuleCount : function() {
+          return this.moduleCount;
+        },
+        make : function() {
+          if (this.typeNumber < 1) {
+            this.typeNumber = 1;
+          }
+          this.makeImpl(false, this.getBestMaskPattern());
+        },
+        makeImpl : function(test, maskPattern) {
+          this.moduleCount = this.typeNumber * 4 + 17;
+          this.modules = new Array(this.moduleCount);
+          for (var row = 0; row < this.moduleCount; row++) {
+            this.modules[row] = new Array(this.moduleCount);
+            for (var col = 0; col < this.moduleCount; col++) {
+              this.modules[row][col] = null;
+            }
+          }
+          this.setupPositionProbePattern(0, 0);
+          this.setupPositionProbePattern(this.moduleCount - 7, 0);
+          this.setupPositionProbePattern(0, this.moduleCount - 7);
+          this.setupTimingPattern();
+          if (this.typeNumber >= 2) {
+            this.setupPositionAdjustPattern();
+          }
+          if (this.typeNumber >= 7) {
+            this.setupTypeNumber(test);
+          }
+          this.setupTypeInfo(test, maskPattern);
+          this.dataCache = this.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
+          this.mapData(this.dataCache, maskPattern);
+        },
+        setupPositionProbePattern : function(row, col) {
+          for (var r = -1; r <= 7; r++) {
+            if (row + r <= -1 || this.moduleCount <= row + r) continue;
+            for (var c = -1; c <= 7; c++) {
+              if (col + c <= -1 || this.moduleCount <= col + c) continue;
+              if ((0 <= r && r <= 6 && (c === 0 || c === 6)) || (0 <= c && c <= 6 && (r === 0 || r === 6)) || (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
+                this.modules[row + r][col + c] = true;
+              } else {
+                this.modules[row + r][col + c] = false;
+              }
+            }
+          }
+        },
+        getBestMaskPattern : function() {
+          var minLostPoint = 0;
+          var pattern = 0;
+          for (var i = 0; i < 8; i++) {
+            this.makeImpl(true, i);
+            var lostPoint = QRUtil.getLostPoint(this);
+            if (i === 0 || minLostPoint > lostPoint) {
+              minLostPoint = lostPoint;
+              pattern = i;
+            }
+          }
+          return pattern;
+        },
+        setupTimingPattern : function() {
+          for (var r = 8; r < this.moduleCount - 8; r++) {
+            if (this.modules[r][6] !== null) continue;
+            this.modules[r][6] = (r % 2 === 0);
+          }
+          for (var c = 8; c < this.moduleCount - 8; c++) {
+            if (this.modules[6][c] !== null) continue;
+            this.modules[6][c] = (c % 2 === 0);
+          }
+        },
+        setupPositionAdjustPattern : function() {
+          var pos = QRUtil.getPatternPosition(this.typeNumber);
+          for (var i = 0; i < pos.length; i++) {
+            for (var j = 0; j < pos.length; j++) {
+              var row = pos[i];
+              var col = pos[j];
+              if (this.modules[row][col] !== null) continue;
+              for (var r = -2; r <= 2; r++) {
+                for (var c = -2; c <= 2; c++) {
+                  if (r === -2 || r === 2 || c === -2 || c === 2 || (r === 0 && c === 0)) {
+                    this.modules[row + r][col + c] = true;
+                  } else {
+                    this.modules[row + r][col + c] = false;
+                  }
+                }
+              }
+            }
+          }
+        },
+        setupTypeNumber : function(test) {
+          var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
+          for (var i = 0; i < 18; i++) {
+            var mod = (!test && ((bits >> i) & 1) === 1);
+            var row = Math.floor(i / 3);
+            var col = i % 3 + this.moduleCount - 8 - 3;
+            this.modules[row][col] = mod;
+            this.modules[col][row] = mod;
+          }
+        },
+        setupTypeInfo : function(test, maskPattern) {
+          var data = (this.errorCorrectLevel << 3) | maskPattern;
+          var bits = QRUtil.getBCHTypeInfo(data);
+          for (var i = 0; i < 15; i++) {
+            var mod = (!test && ((bits >> i) & 1) === 1);
+            if (i < 6) {
+              this.modules[i][8] = mod;
+            } else if (i < 8) {
+              this.modules[i + 1][8] = mod;
+            } else {
+              this.modules[this.moduleCount - 15 + i][8] = mod;
+            }
+            if (i < 8) {
+              this.modules[8][this.moduleCount - i - 1] = mod;
+            } else if (i < 9) {
+              this.modules[8][15 - i - 1 + 1] = mod;
+            } else {
+              this.modules[8][15 - i - 1] = mod;
+            }
+          }
+          this.modules[this.moduleCount - 8][8] = !test;
+        },
+        mapData : function(data, maskPattern) {
+          var inc = -1;
+          var row = this.moduleCount - 1;
+          var bitIndex = 7;
+          var byteIndex = 0;
+          for (var col = this.moduleCount - 1; col > 0; col -= 2) {
+            if (col === 6) col--;
+            while (true) {
+              for (var c = 0; c < 2; c++) {
+                if (this.modules[row][col - c] === null) {
+                  var dark = false;
+                  if (byteIndex < data.length) {
+                    dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);
+                  }
+                  if (QRUtil.getMaskFunction(maskPattern)(row, col - c)) {
+                    dark = !dark;
+                  }
+                  this.modules[row][col - c] = dark;
+                  bitIndex--;
+                  if (bitIndex === -1) {
+                    byteIndex++;
+                    bitIndex = 7;
+                  }
+                }
+              }
+              row += inc;
+              if (row < 0 || this.moduleCount <= row) {
+                row -= inc;
+                inc = -inc;
+                break;
+              }
+            }
+          }
+        },
+        createData : function(typeNumber, errorCorrectLevel, dataList) {
+          var rsBlocks = getRSBlocks(typeNumber, errorCorrectLevel);
+          var buffer = new QRBitBuffer();
+          for (var i = 0; i < dataList.length; i++) {
+            var data = dataList[i];
+            buffer.put(data.mode, 4);
+            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
+            data.write(buffer);
+          }
+          var totalDataCount = 0;
+          for (i = 0; i < rsBlocks.length; i++) {
+            totalDataCount += rsBlocks[i].dataCount;
+          }
+          if (buffer.length + 4 <= totalDataCount * 8) {
+            buffer.put(0, 4);
+          }
+          while (buffer.length % 8 !== 0) {
+            buffer.putBit(false);
+          }
+          var dataBytes = [];
+          while (buffer.length / 8 > totalDataCount) {
+            throw new Error('code length overflow.');
+          }
+          for (i = 0; i < buffer.length / 8; i++) {
+            dataBytes.push(buffer.buffer[i]);
+          }
+          var paddingBytes = [0xec, 0x11];
+          var index = 0;
+          while (dataBytes.length < totalDataCount) {
+            dataBytes.push(paddingBytes[index % 2]);
+            index++;
+          }
+          return createBytes(buffer, rsBlocks);
+        },
+        createSvgTag: function(opts) {
+          opts = opts || {};
+          var cellSize = opts.cellSize || 2;
+          var margin = opts.margin || 4;
+          var size = this.modules.length;
+          var svg = ["<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 " + (size + margin * 2) + " " + (size + margin * 2) + "' shape-rendering='crispEdges'>"];
+          svg.push("<rect width='100%' height='100%' fill='white'/>");
+          var path = [];
+          for (var r = 0; r < size; r++) {
+            for (var c = 0; c < size; c++) {
+              if (this.modules[r][c]) {
+                path.push('M' + (c + margin) + ' ' + (r + margin) + 'h1v1h-1z');
+              }
+            }
+          }
+          svg.push("<path stroke='none' fill='black' d='" + path.join('') + "'/>");
+          svg.push('</svg>');
+          return svg.join('');
+        }
+      };
+
+      function qr8BitByte(data) {
+        var buffer = [];
+        for (var i = 0; i < data.length; i++) {
+          buffer.push(data.charCodeAt(i));
+        }
+        return {
+          mode : mode8bitByte.mode,
+          getLength : function() {
+            return buffer.length;
+          },
+          write : function(bitBuffer) {
+            for (var i = 0; i < buffer.length; i++) {
+              bitBuffer.put(buffer[i], 8);
+            }
+          }
+        };
+      }
+
+      QRUtil.getLengthInBits = function(mode, type) {
+        if (1 <= type && type < 10) {
+          switch(mode) {
+          case 4 : return 8;
+          default : throw new Error('mode:' + mode);
+          }
+        } else if (type < 27) {
+          switch(mode) {
+          case 4 : return 16;
+          default : throw new Error('mode:' + mode);
+          }
+        } else if (type < 41) {
+          switch(mode) {
+          case 4 : return 16;
+          default : throw new Error('mode:' + mode);
+          }
+        } else {
+          throw new Error('type:' + type);
+        }
+      };
+
+      QRUtil.getLostPoint = function(qrCode) {
+        var moduleCount = qrCode.getModuleCount();
+        var lostPoint = 0;
+        for (var row = 0; row < moduleCount; row++) {
+          for (var col = 0; col < moduleCount; col++) {
+            var sameCount = 0;
+            var dark = qrCode.isDark(row, col);
+            for (var r = -1; r <= 1; r++) {
+              if (row + r < 0 || moduleCount <= row + r) {
+                continue;
+              }
+              for (var c = -1; c <= 1; c++) {
+                if (col + c < 0 || moduleCount <= col + c) {
+                  continue;
+                }
+                if (r === 0 && c === 0) {
+                  continue;
+                }
+                if (dark === qrCode.isDark(row + r, col + c)) {
+                  sameCount++;
+                }
+              }
+            }
+            if (sameCount > 5) {
+              lostPoint += (3 + sameCount - 5);
+            }
+          }
+        }
+        for (row = 0; row < moduleCount - 1; row++) {
+          for (col = 0; col < moduleCount - 1; col++) {
+            var count = 0;
+            if (qrCode.isDark(row, col)) count++;
+            if (qrCode.isDark(row + 1, col)) count++;
+            if (qrCode.isDark(row, col + 1)) count++;
+            if (qrCode.isDark(row + 1, col + 1)) count++;
+            if (count === 0 || count === 4) {
+              lostPoint += 3;
+            }
+          }
+        }
+        for (row = 0; row < moduleCount; row++) {
+          for (col = 0; col < moduleCount - 6; col++) {
+            if (qrCode.isDark(row, col)
+                && !qrCode.isDark(row, col + 1)
+                && qrCode.isDark(row, col + 2)
+                && qrCode.isDark(row, col + 3)
+                && qrCode.isDark(row, col + 4)
+                && !qrCode.isDark(row, col + 5)
+                && qrCode.isDark(row, col + 6)) {
+              lostPoint += 40;
+            }
+          }
+        }
+        for (col = 0; col < moduleCount; col++) {
+          for (row = 0; row < moduleCount - 6; row++) {
+            if (qrCode.isDark(row, col)
+                && !qrCode.isDark(row + 1, col)
+                && qrCode.isDark(row + 2, col)
+                && qrCode.isDark(row + 3, col)
+                && qrCode.isDark(row + 4, col)
+                && !qrCode.isDark(row + 5, col)
+                && qrCode.isDark(row + 6, col)) {
+              lostPoint += 40;
+            }
+          }
+        }
+        var darkCount = 0;
+        for (col = 0; col < moduleCount; col++) {
+          for (row = 0; row < moduleCount; row++) {
+            if (qrCode.isDark(row, col)) {
+              darkCount++;
+            }
+          }
+        }
+        var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
+        lostPoint += ratio * 10;
+        return lostPoint;
+      };
+
+      function createBytes(buffer, rsBlocks) {
+        var offset = 0;
+        var maxDcCount = 0;
+        var maxEcCount = 0;
+        var dcdata = [];
+        var ecdata = [];
+        for (var r = 0; r < rsBlocks.length; r++) {
+          var dcCount = rsBlocks[r].dataCount;
+          var ecCount = rsBlocks[r].totalCount - dcCount;
+          maxDcCount = Math.max(maxDcCount, dcCount);
+          maxEcCount = Math.max(maxEcCount, ecCount);
+          dcdata[r] = new Array(dcCount);
+          for (var i = 0; i < dcCount; i++) {
+            dcdata[r][i] = buffer.buffer[offset + i];
+          }
+          offset += dcCount;
+          var rsPoly = qrPolynomial([1], 0);
+          for (i = 0; i < ecCount; i++) {
+            rsPoly = rsPoly.multiply(qrPolynomial([1, QRMath.gexp(i)], 0));
+          }
+          var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);
+          var modPoly = rawPoly.mod(rsPoly);
+          ecdata[r] = new Array(rsPoly.getLength() - 1);
+          for (i = 0; i < ecdata[r].length; i++) {
+            var modIndex = i + modPoly.getLength() - ecdata[r].length;
+            ecdata[r][i] = (modIndex >= 0) ? modPoly.get(modIndex) : 0;
+          }
+        }
+        var totalCodeCount = 0;
+        for (r = 0; r < rsBlocks.length; r++) {
+          totalCodeCount += rsBlocks[r].totalCount;
+        }
+        var data = new Array(totalCodeCount);
+        var index = 0;
+        for (i = 0; i < maxDcCount; i++) {
+          for (r = 0; r < rsBlocks.length; r++) {
+            if (i < rsBlocks[r].dataCount) {
+              data[index++] = dcdata[r][i];
+            }
+          }
+        }
+        for (i = 0; i < maxEcCount; i++) {
+          for (r = 0; r < rsBlocks.length; r++) {
+            if (i < rsBlocks[r].totalCount - rsBlocks[r].dataCount) {
+              data[index++] = ecdata[r][i];
+            }
+          }
+        }
+        return data;
+      }
+
+      window.qrcode = function(typeNumber, errorCorrectLevel) {
+        var levels = { L: 0, M: 1, Q: 2, H: 3 };
+        var level = errorCorrectLevel;
+        if (typeof level === 'string') {
+          level = levels[level.toUpperCase()] !== undefined ? levels[level.toUpperCase()] : levels.M;
+        }
+        if (typeof level !== 'number' || level < 0 || level > 3) {
+          level = levels.M;
+        }
+        var initialVersion = typeNumber < 1 ? 1 : typeNumber;
+        var qr = new QRCodeModel(initialVersion, level);
+        return {
+          addData: function(data) {
+            qr.addData(data);
+          },
+          make: function() {
+            if (typeNumber < 1) {
+              var version = 1;
+              while (version <= 40) {
+                try {
+                  qr.typeNumber = version;
+                  qr.dataCache = null;
+                  qr.make();
+                  break;
+                } catch (error) {
+                  if (error && typeof error.message === 'string' && error.message.indexOf('code length overflow') >= 0) {
+                    version++;
+                    continue;
+                  }
+                  throw error;
+                }
+              }
+              if (version > 40) {
+                throw new Error('code length overflow.');
+              }
+            } else {
+              qr.make();
+            }
+          },
+          createSvgTag: function(options) {
+            return qr.createSvgTag(options);
+          }
+        };
+      };
+      };
+    })();
+  </script>
+</body>
+</html>

